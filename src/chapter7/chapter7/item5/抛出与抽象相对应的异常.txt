                                                          抛出与抽象相对应的异常

当方法传递由低层抽象抛出的异常时，往往会发生方法抛出的异常与它所执行的任务没有明显的关联关系的情况。
除了使人感到困惑之外，也让实现细节污染了更高层的 API。如果高层的实现在后续版本中发生了变化，它所抛出的异常也可能会跟着发生变化，从而潜在地破坏现有的客户程序。

为了避免这个问题，更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这称为异常转译。
如：

try{
// 这里调用低层的方法可能会抛出一个低层异常
}catch(LowerLevelException e){
  throw new HigherLevelException(...);// 转译为高层异常
}

如果低层的异常对于调试导致高层异常的情形非常有帮助，使用异常链更合适。低层的异常被传到高层的异常，并且高层异常提供公有的访问方法来获得低层的异常。
如：

try{
// 这里调用低层的方法可能会抛出一个低层异常
}catch(LowerLevelException e){
  throw new HigherLevelException(e);// 异常链
}

大多数标准的异常都支持链的构造器。对于没有支持链的异常，可以利用 Throwable 的 initCause 方法设置原因。


处理来自低层异常最好的做法是，在调用低层方法之前确保它们会成功执行，从而避免抛出异常。比如给底层传递参数之前进行有效性校验。
次选方案是，在调用低层方法的高层代码中处理（吞掉）这些异常（如捕获异常之后进行日志logging），从而将高层方法的调用者和低层的问题隔离开。
最后的做法是，使用异常转译，将低层异常转译之后抛给高层方法的调用者。
