                                                           覆盖equals时总是要覆盖hashCode


在每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。如果不这样做，就会违反Object.hashCode的通用约定，
从而导致该类无法与所有基于散列（hash）的集合一起正常工作，包括 HashMap、HashSet 和 Hashtable。

hashCode 规范：

1，在应用程序执行期间，只要对象的 equals 方法作比较所用到的信息没有被修改，那么对该对象多次调用 hashCode方法都必须始终如一地返回同一个整数。
在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不同，即这个应用程序这次执行返回的整数与下一次执行返回的整数可以不一致。

2，如果两个对象根据 equals 方法比较是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法必须产生相同的整数结果。

3，如果两个对象根据 equals 方法比较是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，不要求必须产生不同的整数结果。
然而，对于不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。

根据第二条约定，所以要在覆盖 equals 时总是要覆盖 hashCode，以便相等的对象有相等的散列码。

一个好的散列函数倾向于“为不相等的对象产生不相等的散列码”。

下面是简单的解决方法：

1，把某个非零常数值，比如说17，保存在一个叫 result 的 int 类型的变量中。
2，对于对象中每一个关键域f（指equals方法中考虑到的每一个域），完成以下步骤：
 a，为该域计算int类型的散列码c：
   1，如果该域是boolean类型，则计算(f ? 0 : 1)。
   2，如果该域是byte、char、short或者int类型，则计算(int) f。
   3，如果该域是long类型，则计算(int) (f ^ (f >>> 32))。
   4，如果该域是float类型，则计算Float.floatToIntBits(f)。
   5，如果该域是double类型，则计算Double.doubleToLongBits(f)得到一个long类型的值，然后按照步骤 2.a.3，对该long值计算散列值。
   6，如果该域是一个对象引用，并且该类的equals方法通过递归调用equals的方式来比较这个域，则同样对这个域递归调用hashCode。
               如果这个域的值为null，则返回0(或者是其他常数，习惯用0)。
   7，如果该域是一个数组，则把每一个元素当做单独的域来处理。
              也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤2.b中的做法把这些散列值组合起来。
 b，按照下面的公式把步骤a中计算得到的散列码c组合到result中：
    result = 37 * result + c;
3，返回result。
4，写完hashCode之后，确认是否相等的实例具有相等的散列码。

如果一个域的值可以根据参与计算的其他域值计算出来，则把这样的域排除在外是可以接受的。
对于在 equals 比较计算中没有被用到的任何域，要把它们排除在外，这是一个要求。