                                                          抛出的异常要适合相应的抽象

如果一个方法抛出的异常与它所执行的任务没有明显的关联关系，这样会使人不知所措。当一个方法传递一个由低层抽象抛出的异常时，往往会发生这样的情况。除了使人感到困惑之外，也污染了具有实现细节的高层API。如果高层的实现在后续版本中发生了变化，那么它所抛出的异常也可能会跟着发生变化，从而会潜在的打破现有的客户程序。

为了避免这个问题，方案如下：
高层的实现应该捕获低层的异常，同时抛出一个可以按照高层抽象进行解释的异常。这称为异常转移。如：

try{
// 这里调用低层的方法可能会抛出一个低层异常
}catch(LowerLevelException e){
  throw new HigherLevelException(...);// 转译为高层异常
}

如果低层的异常对于调试该异常被抛出的情形非常有帮助，那么使用异常链接是很合适的。在这种方法中，低层异常被高层异常保存起来，并且高层异常提供一个公有的访问方法来获得低层的异常。如：

try{
// 这里调用低层的方法可能会抛出一个低层异常
}catch(LowerLevelException e){
  throw new HigherLevelException(e);// 异常链接
}


如果可能的话，处理来自低层异常最好的做法是，在调用低层方法之前确保它们会成功执行，从而避免它们会抛出异常。
退而求其次的做法是，在调用低层方法的高层代码中处理(吃掉)这些异常(如捕获异常之后进行日志logging)，从而将高层方法的调用者和低层的问题隔离开。
再次的做法是，使用异常转译，将低层异常转译之后抛给高层方法的调用者。