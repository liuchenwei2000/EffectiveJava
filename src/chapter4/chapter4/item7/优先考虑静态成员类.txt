                                                                                                                    优先考虑静态成员类

嵌套类(nested class)是指被定义在另一个类的内部的类。嵌套类存在的目的应该只是为它的外围类提供服务。

嵌套类有四种：静态成员类(static member class)、非静态成员类(nonstatic member class)、匿名类(anonymous class)和局部类(local class)。
除了第一种之外，其他三种都被称为内部类(inner class)。


1，静态成员类

它是最简单的嵌套类，可以把它看作是一个普通的类，只是碰巧被声明在另一个类的内部，它可以访问外围类的所有成员，包括那些声明为私有的成员。
静态成员类是外围类的一个静态成员，与其他的静态成员一样，也遵守同样的可访问性规则。
如果它被声明为私有的，那么只能在它的外围类的内部才可以被访问等等。

静态成员类的典型用法有两种，可见chapter4.item18.StaticMemberClassDemo1.java和chapter4.item18.StaticMemberClassDemo2.java。

2，非静态成员类

从语法上讲，静态成员类和非静态成员类之间唯一的区别是：静态成员类的声明中包含static。
除此之外，非静态成员类的每一个实例都隐含着与外围类的一个外围实例紧密关联在一起。
在非静态成员类的实例方法内部，调用外围实例上的方法是有可能的，或者使用经过修饰的this也可以得到一个指向外围实例的引用。
在没有外围实例的情况下要想创建非静态成员类的实例是不可能的。当非静态成员类的实例被创建的时候，它和外围实例之间的关联关系也随之被建立起来；
而且，这种关联关系以后不能被修改。通常情况下，当外围类的某个实例方法的内部调用非静态成员类的构造函数时，这种关联关系被自动建立起来。
使用表达式outerInstance.new MemberClass()来手工建立这种关联关系也是有可能的，但是很少使用。
这种关联关系需要消耗非静态成员实例的空间，并且在构造的过程中增加了时间开销。

非静态成员类的典型用法可见chapter4.item18.NonstaticMemberClassDemo.java。

如果声明的成员类不要求访问外围实例，那么记住把static修饰符放到成员类的声明中，使它成为一个静态成员类。

如果嵌套类是一个导出类的公有的或受保护的成员，则必须要在静态和非静态成员类之间做出正确的选择。
在这种情况下，该成员类是导出的API中的一个元素，在后续的版本中，要想不违背二进制兼容性，就不能从非静态成员类变为静态成员类。

3，匿名类

匿名类没有名字，它不是外围类的一个成员。它并不与其他的成员一起被声明，而是在被使用的点上同时被声明和实例化。
匿名类可以出现在代码中任何允许表达式出现的地方。匿名类的行为与静态的或者非静态的成员类非常相似，取决于它所在的环境：
如果匿名类出现在一个非静态的环境中，则它有一个外围实例。

匿名类的适用性有一些限制：
1，因为它同时被声明和实例化，所以匿名类只能被用在代码中它将被实例化的那个点上。
2，因为它没有名字，所以在它被实例化之后，就不能够再对它进行引用，如果不是这种情况就不能使用匿名类。
3，它通常实现了接口中或者超类中的方法，不会声明任何新的方法，因为不存在可命名的类型可以访问新增加的方法。
4，因为它出现在表达式的中间，所以它应该非常简短，太长的匿名类会影响程序的可读性。

匿名类的典型用法可见chapter4.item18.AnonymouseClassDemo.java。

4，局部类

在任何可以声明局部变量的地方，都可以声明局部类，并且局部类也遵守同样的作用域规则。

与成员类一样，局部类有名字，可以被重复使用；与匿名类一样，当且仅当局部类被用于非静态环境下的时候，
它们才有外围实例，并且它们必须非常简短，以便不会损害可读性。

局部类的用法可见chapter4.item18.LocalClassDemo。


总结

如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合于放在一个方法内部，那么应该使用成员类。
如果成员类的每个实例都需要一个指向其外围实例的引用，则把成员类做成非静态的；否则做成静态的。
假设一个嵌套类属于一个方法的内部，如果只需要在一个地方创建它的实例，
并且已经有了一个预先存在的类型可以说明这个类的特征，则把它做成匿名类；否则就做成局部类。